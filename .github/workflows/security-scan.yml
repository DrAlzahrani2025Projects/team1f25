name: Docker Scout Report
on:
  push:
    branches: ["*"]
  pull_request:
    branches: ["*"]
  workflow_dispatch:

concurrency:
  group: docker-scout-${{ github.ref }}
  cancel-in-progress: true

jobs:
  report:
    # Prevent infinite re-triggers from our own "Add Docker Scout Report" commit
    if: github.actor != 'github-actions[bot]' && !contains((github.event.head_commit.message || ''), 'Add Docker Scout Report')
    name: Build image, scan with Docker Scout CLI, and write Markdown
    runs-on: ubuntu-latest
    timeout-minutes: 20

    permissions:
      contents: write  # needed to commit docs/ on trusted events

    env:
      BRANCH_NAME: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.ref || github.ref_name }}
      SCAN_DIR: .scan
      SCAN_JSON: .scan/report.json

    steps:
      - name: Checkout (on real branch)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH_NAME }}
          fetch-depth: 0
          persist-credentials: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Choose local tag
        id: tag
        run: echo "val=local/team1f25-streamlit:${{ github.sha }}" >> "$GITHUB_OUTPUT"

      - name: Build image (local only; no push)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile
          platforms: linux/amd64
          load: true
          push: false
          tags: ${{ steps.tag.outputs.val }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Prepare scan dir
        run: mkdir -p "$SCAN_DIR"

      # Authenticate to Docker Hub only on trusted events (NOT forked PRs)
      - name: Log in to Docker Hub
        if: >
          github.event_name != 'pull_request' ||
          (github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false)
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Install Docker Scout CLI plugin (portable installer)
      - name: Install Docker Scout CLI
        run: |
          echo "Installing Docker Scout CLI..."
          curl -fsSL https://raw.githubusercontent.com/docker/scout-cli/main/install.sh -o install-scout.sh
          chmod +x install-scout.sh
          sudo ./install-scout.sh -b /usr/local/bin
          
          echo "Verifying installation..."
          if command -v docker-scout &> /dev/null; then
            echo "✓ Docker Scout CLI installed successfully"
            docker-scout version
          else
            echo "⚠ Docker Scout CLI installation failed"
            echo "Available docker commands:"
            docker --help | grep -A 20 "Management Commands" || true
          fi

      # Run Docker Scout CLI to produce SARIF JSON (trusted contexts only)
      - name: Export vulnerabilities to SARIF JSON via Docker Scout CLI
        if: >
          github.event_name != 'pull_request' ||
          (github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false)
        run: |
          echo "Running Docker Scout scan..."
          
          # Try docker-scout command (standalone CLI)
          if command -v docker-scout &> /dev/null; then
            echo "Using docker-scout CLI..."
            if docker-scout cves --format sarif "${{ steps.tag.outputs.val }}" > "$SCAN_JSON" 2>&1; then
              echo "✓ Docker Scout scan completed successfully"
              ls -lh "$SCAN_JSON"
            else
              echo "⚠ Docker Scout scan failed"
              cat "$SCAN_JSON" 2>/dev/null || true
              echo '{"runs":[{"tool":{"driver":{"name":"docker scout"}},"results":[]}]}' > "$SCAN_JSON"
            fi
          else
            echo "⚠ Docker Scout CLI not available"
            echo "Skipping scan - creating empty SARIF placeholder..."
            echo '{"runs":[{"tool":{"driver":{"name":"docker scout"}},"results":[]}], "_note":"Docker Scout CLI not installed"}' > "$SCAN_JSON"
          fi

      # Last resort: ensure a tiny placeholder so the Markdown step never 'skips'
      - name: Ensure placeholder report.json if absent
        if: always()
        run: |
          if [ ! -f "$SCAN_JSON" ]; then
            echo "⚠ SARIF file missing - creating placeholder"
            echo '{"runs":[{"tool":{"driver":{"name":"docker scout"}},"results":[]}], "_note":"scan was skipped or failed"}' > "$SCAN_JSON"
          elif [ ! -s "$SCAN_JSON" ]; then
            echo "⚠ SARIF file is empty (0 bytes) - replacing with placeholder"
            echo '{"runs":[{"tool":{"driver":{"name":"docker scout"}},"results":[]}], "_note":"scan produced empty output"}' > "$SCAN_JSON"
          else
            echo "✓ SARIF file exists and has content"
          fi

      - name: Debug SARIF file presence
        if: always()
        run: |
          echo "PWD: $(pwd)"
          ls -la
          echo "SCAN_DIR listing:"
          ls -la "$SCAN_DIR" || true
          if [ -f "$SCAN_JSON" ]; then
            echo "Found $SCAN_JSON - file size:"
            ls -lh "$SCAN_JSON"
            echo "First 500 bytes:"
            head -c 500 "$SCAN_JSON" || true
            echo
            echo "Checking structure:"
            jq -r '.runs[0].results | length' "$SCAN_JSON" 2>&1 || echo "Failed to parse results"
            echo "Checking rules:"
            jq -r '.runs[0].tool.driver.rules | length' "$SCAN_JSON" 2>&1 || echo "Failed to parse rules"
          else
            echo "MISSING $SCAN_JSON"
          fi

      - name: Generate Markdown report
        if: always()
        run: |
          mkdir -p docs
          {
            echo "# Docker Scout Security Vulnerability Report"
            echo
            echo "**Date:** $(date -u)"
            echo "**Git SHA:** ${{ github.sha }}"
            echo "**Branch/Ref:** ${{ env.BRANCH_NAME }}"
            echo
            echo "## Image Scanned"
            echo "\`${{ steps.tag.outputs.val }}\`"
            echo
            echo "## Summary of Vulnerabilities"
            echo
            echo "| Severity | CVE | Package | Ecosystem | Affected | Fixed | Description |"
            echo "|---|---|---|---|---|---|---|"

            # Write rows to a temp file so we can detect empty/failed output
            jq -r '
              def purl_info(p):
                if (p // "") == "" then {eco:"N/A", name:"N/A", ver:"N/A"}
                else
                  (p | sub("^pkg:";"")) as $s
                  | ($s | split("/")) as $parts
                  | ($parts[0] // "unknown") as $eco
                  | ($parts[-1] // "") as $last
                  | ($last | split("@")) as $nv
                  | {eco:$eco, name: ($nv[0] // "unknown"), ver: (($nv[1] // "" ) | split("?")[0] // "N/A")}
                end;

              .runs[0] as $run
              | ($run.tool.driver.rules // []) as $rules
              | (reduce $rules[] as $r ({}; . + { ($r.id): $r })) as $rules_by_id
              | ($run.results // [])
              | map(
                  . as $res
                  | ($rules_by_id[$res.ruleId] // {}) as $rule
                  | ($rule.properties.purls[0]? // "") as $purl
                  | purl_info($purl) as $pkg
                  | {
                      sev: (($rule.properties.cvssV3_severity // $res.level // "N/A") | ascii_upcase),
                      cve: ($res.ruleId // "N/A"),
                      package: ($pkg.name + "@" + $pkg.ver),
                      eco: $pkg.eco,
                      affected: ($rule.properties.affected_version // "N/A"),
                      fixed: ($rule.properties.fixed_version // "N/A"),
                      desc: (
                        ($rule.shortDescription.text // $rule.help.text // $res.message.text // "")
                        | split("\n")[0]
                        | gsub("^>\\s*"; "")
                        | gsub("\\s+"; " ")
                      )
                    }
                )
              | sort_by(
                  if .sev=="CRITICAL" then 5
                  elif .sev=="HIGH" then 4
                  elif .sev=="MEDIUM" then 3
                  elif .sev=="LOW" then 2
                  elif .sev=="WARNING" then 1
                  else 0 end
                )
              | reverse
              | .[]
              | "| \(.sev) | \(.cve) | \(.package) | \(.eco) | \(.affected) | \(.fixed) | \(.desc) |"
            ' "$SCAN_JSON" > .scan/_rows.md 2>.scan/_jq_errors.txt || echo "__JQ_ERROR__" > .scan/_rows.md

            if grep -q "__JQ_ERROR__" .scan/_rows.md; then
              echo "| — | — | — | — | — | — | (jq parse error; see logs) |"
              echo "JQ Error details:"
              cat .scan/_jq_errors.txt 2>/dev/null || echo "No error details available"
            elif [ ! -s .scan/_rows.md ]; then
              # No rows emitted; decide whether it was truly empty or skipped/auth issue
              COUNT="$(jq -r '(.runs[0].results // []) | length' "$SCAN_JSON" 2>/dev/null || echo 0)"
              if [ "$COUNT" = "0" ]; then
                if jq -e 'has("_note")' "$SCAN_JSON" >/dev/null 2>&1; then
                  NOTE="$(jq -r '._note // "unknown reason"' "$SCAN_JSON")"
                  echo "| — | — | — | — | — | — | ⚠ Scan skipped or failed: $NOTE |"
                else
                  echo "| — | — | — | — | — | — | ✓ No vulnerabilities found. |"
                fi
              else
                echo "| — | — | — | — | — | — | ⚠ Found $COUNT results but parsing failed. Check logs. |"
              fi
            else
              cat .scan/_rows.md
            fi

            echo
            echo "_Legend: Severity from CVSS where available; otherwise SARIF level._"
            echo
            echo "---"
            echo "_Generated automatically by Docker Scout CLI (SARIF)_"
          } > docs/Docker_Scout_Report.md


      - name: Upload Markdown and SARIF JSON as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-scout-markdown-and-sarif
          path: |
            docs/Docker_Scout_Report.md
            ${{ env.SCAN_JSON }}
          retention-days: 7

      # Commit report back to repo only on trusted contexts (not forked PRs)
      - name: Commit Docker Scout Report
        if: >
          ( github.event_name != 'pull_request' ) ||
          ( github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false )
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin "${BRANCH_NAME}" || true
          git add docs/Docker_Scout_Report.md
          git commit -m "Add Docker Scout Report for ${{ github.sha }}" || echo "No changes to commit"
          git push origin HEAD:"${BRANCH_NAME}"
